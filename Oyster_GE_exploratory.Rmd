---
title: "Ocean acidification and boring sponge on *Crassostrea virginica* GE"
date: "*Last run on `r format(Sys.time(), '%d %B %Y')`*"
output: 
  html_document:
    theme: simplex
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: hide
---

---

<style>
  h2{color: #DC7633 !important}
  h1{color: #5499C7 !important}
  body{background-color: white !important}
</style>

<style>
.list-group-item.active, .list-group-item.active:hover, .list-group-item.active:focus {
    color: #212F3D;
    background-color: #EDBB99;
    font-weight: bold;}
a {
    color: #5499C7;}
.nav-tabs > li.active > a, .nav-tabs > li.active > a:hover, .nav-tabs > li.active > a:focus {
    color: #DC7633;}
body {
    font-family: "Open Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    font-size: 13px;
    line-height: 1.42857143;
    color: #212F3D;}
</style>

---

```{r setup, include = FALSE} 

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
options(knitr.kable.NA = '')

library("knitr")

date <- Sys.Date() # For saving with the current date
set.seed(7) # set seed


## Setting standard theme for ggplot for all plots:
theme_bove <- function(base_size = 14) {
  theme_bw(base_size = base_size) %+replace%
    theme(
      # remove the gridlines
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      # remove formatting on background
      strip.background = element_blank(),
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "transparent", colour = NA),
      # modify legend theme
      legend.position = "none",
      legend.background = element_rect(fill = "transparent", colour = "transparent"),
      legend.key = element_rect(fill = "transparent", colour = "transparent")
    )
}


## Source the custom functions file:
#source("Code/CustomFunctions.R")

```

```{r install packages, eval = FALSE, include = FALSE}

### If any packages are not installed or need to be updated, you can look for them below:
## get gridSVG from github directly
# library(devtools) 
# devtools::install_github("cran/gridSVG")
# devtools::install_github('sinhrks/ggfortify')
# devtools::install_github("ropensci/rnaturalearthhires")

## get Bioconductor packages
if (!requireNamespace("BiocManager"))
install.packages("BiocManager")
BiocManager::install("DESeq2")

## installing WGCNA:
# source("http://bioconductor.org/biocLite.R")
BiocManager::install(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
BiocManager::install("WGCNA", dependencies=TRUE)
BiocManager::install("arrayQualityMetrics", dependencies=TRUE) # use this arrayQualityMetrics install if using later versions of R (3.6.3 works)
#repos="http://cran.us.r-project.org"

## R version 3.6 is funky with arrayQualityMetrics so need this work around:
install.packages("ape", lib = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
library(ape, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages("magick", lib = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library", dependencies = FALSE)
library(magick, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
BiocManager::install("arrayQualityMetrics", type = "source", checkBuilt = TRUE, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")



### Used packages that need to be installed to run code (and can be sourced easier from CRAN):
needed_packages <- c("tidyverse", "dplyr", "readr", "plotly", "vegan", "data.table", "ggpubr", "pdftools", "ggrepel", "adegenet") # Specify necessary packages

not_installed <- needed_packages[!(needed_packages %in% installed.packages()[ , "Package"])] # Extract not installed packages
if(length(not_installed)) install.packages(not_installed) # Install not installed packages

```

```{r load packages, include=FALSE}

library(tidyverse)
library(dplyr)
#library(arrayQualityMetrics) # need special install above
library(ggplot2)
library(readr)
library(plotly)
library(DESeq2) # need special install above
library(vegan)
library(data.table)
library(ggpubr)
library(pdftools)
library(ggrepel)
library(adegenet)
library(ggvenn)

source("Code/CustomFunctions.R")

```


## Expoloring data {.tabset}

```{r read in data}

# read in the counts file
counts <- read.table("Data/CVIR_featurecounts_22Jun22.txt", header = TRUE, row.names = 1)
counts <- counts[c(-1:-5, -37)] # removing columns 1-5 since we do not need them for this (and the Undetermined column)
col_names <- colnames(counts)

# Remove some of the extra stuff in the column names to match with expDesign
col_names <- gsub("X", "", col_names)
col_names <- gsub("\\_S.*", "", col_names)
colnames(counts) <- col_names

# read in the experimental design .csv
expDesign <- read.csv("Data/cvir_expDesign.csv")
expDesign <- expDesign[match(col_names, expDesign$Sample_ID),] # reorder samples to match count df
expDesign$infect <- factor(expDesign$infect)
expDesign$pCO2 <- factor(expDesign$pCO2)
expDesign$Sample_ID <- factor(expDesign$Sample_ID)
expDesign$treat <- factor(paste(expDesign$infect, expDesign$pCO2, sep = "_"))

```

<br/>

### Filtering counts

```{r unfiltered size factor plots, fig.width = 10, fig.height = 4}

nrow <- nrow(counts) # number of rows/counts (38828)
countMat <- DESeqDataSetFromMatrix(counts, expDesign, ~ 1) # makes a DESeqDataSet object with count data, experimental design, and no design formula
counts_SF <- estimateSizeFactors(countMat) #  estimates the size factors using the "median ratio method" described by Equation 5 in Anders and Huber (2010)

# make dataframe of the size factors to visualize
sizeFactors <- data.frame(sample = counts_SF@colData@listData[["Sample_ID"]], treat = counts_SF@colData@listData[["treat"]], sizeFactors = counts_SF@colData@listData[["sizeFactor"]])

# plot sizeFactors
ggplot(data = sizeFactors, aes(x = sample, y = sizeFactors, fill = treat)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_brewer(palette = 2, type = "qual") +
  geom_bar(stat = "identity") +
  ggtitle("Unfiltered sizeFactors")

```

Figure 1: Size factors of initial oyster samples in the study, calculated using oyster gene count data.

After viewing the size factors, it appears that we have 5 samples with really low values that should be removed:

* 19355
* 19372
* 19382
* 19496
* 19505

<br/>


```{r filter low reads (base mean 3)}

### Filtered counts and remove outliers (less than 3)

## remove rows with no or low counts (remove ones with base mean lower than 3)
keep <- rowSums(counts(counts_SF)) >= 3
counts_filter <- counts[keep,]
nrow_filter <- nrow(counts_filter)
# the updated number of rows (24384)


## outliers removed based on array quality metrics
outs <- c(14, 16, 18, 23, 24) # pull these outliers
filter_counts_out <- counts_filter[,-outs]
expDesign <- expDesign[-outs,]

```

```{r filtered size factor plots, fig.width = 10, fig.height = 4}

## Redo the count matrix steps from above with the filtered data
filt_countMat <- DESeqDataSetFromMatrix(filter_counts_out, expDesign, ~ 1) # makes a DESeqDataSet object with count data, experimental design, and no design formula
counts_SF_filter <- estimateSizeFactors(filt_countMat) #  estimates the size factors using the "median ratio method" described by Equation 5 in Anders and Huber (2010)


# make dataframe of the size factors to visualize
sizeFactors_filter <-  data.frame(sample = counts_SF_filter@colData@listData[["Sample_ID"]], treat = counts_SF_filter@colData@listData[["treat"]], sizeFactors = counts_SF_filter@colData@listData[["sizeFactor"]])

# plot sizeFactors
ggplot(data = sizeFactors_filter, aes(x = sample, y = sizeFactors, fill = treat)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_brewer(palette = 2, type = "qual") +
  geom_bar(stat = "identity") +
  ggtitle("Filtered sizeFactors")

```

Figure 2: Size factors of oyster samples remaining in the study after 5 outliers were removed, calculated using oyster gene count data.

Without filtering low reads, we had a total of **`r nrow`** counts. After filtering out the low counts (those with a base mean less than 3), we now have **`r  nrow_filter`** counts remaining for all *C. virginica* samples.

<br/>
<br/>


### PCA plots of Global Gene Expression 

```{r dds model and save, eval = FALSE, echo=TRUE}

# going to use the filter_counts_out object created above because it is filtered for low reads and has outliers removed

## create the DESeq object
dds <- DESeqDataSetFromMatrix(countData = filter_counts_out, 
                              colData = expDesign,
                              design = ~ treat)
dds <- DESeq(dds) # differential expression analysis on gamma-poisson distribution
vsd <-varianceStabilizingTransformation(dds, blind = TRUE) # quickly estimate dispersion trend and apply a variance stabilizing transformation

## Save dds and vsd data 
save(dds, vsd, file = "Data/transformed_counts.RData")

```

```{r normalized count table}

## Load previously saved dds and vsd data 
load("Data/transformed_counts.RData")

## Normalize counts for table
dds <- estimateSizeFactors(dds)
norm_counts <- counts(dds, normalized = TRUE)

```

```{r GE PCA, include=FALSE}

## calculate PCs based on the vsd transformed GE
pcaData <- plotPCA_allPCs(vsd, intgroup = c("treat", "pCO2", "infect"), returnData = TRUE) # will provide all PCs
#head(pcaData)

# extract variance for all PCs
percentVar <- round((100 * attr(pcaData, "percentVar")), 2)

```


```{r PERMANOVA}

# run the PERMANOVA with euclidean distances and 1500 iterations
#head(pcaData[6:31])
GE_pca <- adonis2(pcaData[6:31] ~ pcaData$infect * pcaData$pCO2, method = 'eu', permutations = 1500)
GE_pca

```

<br/>


```{r GE PCA plot, fig.align='center', fig.width = 8, fig.height = 6}

## PCA: treatment effects (crossed)
pca_plot <- ggplot(pcaData, aes(x = PC1, y = PC2)) +
  geom_point(size = 3, aes(colour = treat),alpha = 0.8) +
  stat_ellipse(geom = "polygon", aes(colour = treat), fill = NA, type = "t", level = 0.95, show.legend = FALSE) +
  xlab(paste0("PC1 (", percentVar[1], "%)")) +
  ylab(paste0("PC2 (", percentVar[2], "%)")) +
  scale_colour_brewer(palette = 2, type = "qual") +
  theme_classic()

pca_plot

ggsave("Figures/FigureXX_GEpca.pdf", width = 6, height = 4)
ggsave("Figures/FigureXX_GEpca.png", width = 6, height = 4)



```

Figure 3: PCA plot with each point being one oyster sample colored by treatment. Orange represents the control treatment (no boring sponge, pCO2 level 400), green represents no sponge, pCO2 level 2800, purple represents samples infected with boring sponge at pCO2 2800, and pink represents samples infected with boring sponge at pCO2 400.

<br/>
<br/>


## Differential gene expression {.tabset}

<br/>

### DEGs 

```{r general results of DEGs}

## Fist, we will look at the general 'results()' function
results(dds)
summary(results(dds))

```

```{r create results of DEGs by contrasts}

## When specifying your contrasts, make sure you 'control' level is the second value input and your 'treatment' is the first
res_con_sponge <- results(dds, contrast = c("treat", "S_400", "N_400"), alpha = 0.05)
res_con_pco2 <- results(dds, contrast = c("treat", "N_2800", "N_400"), alpha = 0.05)
res_trt <- results(dds, contrast = c("treat", "S_2800", "N_400"), alpha = 0.05)

#new
res_trt_pco2 <- results(dds, contrast = c("treat", "S_2800", "S_400"), alpha = 0.05)
res_stn_pco2 <- results(dds, contrast = c("treat", "S_400", "N_2800"), alpha = 0.05)
res_shn_pco2 <- results(dds, contrast = c("treat", "S_2800", "N_2800"), alpha = 0.05)

```

```{r results summary, echo = TRUE}

summary(res_con_sponge)
summary(res_con_pco2)
summary(res_trt)
summary(res_trt_pco2)
summary(res_stn_pco2)
summary(res_shn_pco2)

```

```{r filter for DEGs}

## Filter for DEG per pairwise comparison (adjusted p value = 0.05)
# sponge v no sponge at control pCO2
downCon_S <- row.names(res_con_sponge[res_con_sponge$padj < 0.05 & !is.na(res_con_sponge$padj) & res_con_sponge$log2FoldChange < 0, ])
upCon_S <- row.names(res_con_sponge[res_con_sponge$padj < 0.05 & !is.na(res_con_sponge$padj) & res_con_sponge$log2FoldChange > 0, ])

# pCO2 with no sponge
downTrt_N <- row.names(res_con_pco2[res_con_pco2$padj < 0.05 & !is.na(res_con_pco2$padj) & res_con_pco2$log2FoldChange < 0, ])
upTrt_N <- row.names(res_con_pco2[res_con_pco2$padj < 0.05 & !is.na(res_con_pco2$padj) & res_con_pco2$log2FoldChange > 0, ])

# control v double trt (sponge at high pCo2)
downTrt_S <- row.names(res_trt[res_trt$padj < 0.05 & !is.na(res_trt$padj) & res_trt$log2FoldChange < 0, ])
upTrt_S <- row.names(res_trt[res_trt$padj < 0.05 & !is.na(res_trt$padj) & res_trt$log2FoldChange > 0, ])

#sponge high vs sponge low
downtrtS <- row.names(res_trt_pco2[res_trt_pco2$padj < 0.05 & !is.na(res_trt_pco2$padj) & res_trt$log2FoldChange < 0, ])
uptrtS <- row.names(res_trt_pco2[res_trt_pco2$padj < 0.05 & !is.na(res_trt_pco2$padj) & res_trt$log2FoldChange > 0, ])

#sponge low vs no sponge high
downslsh <- row.names(res_stn_pco2[res_stn_pco2$padj < 0.05 & !is.na(res_stn_pco2$padj) & res_trt$log2FoldChange < 0, ])
upslsh <- row.names(res_stn_pco2[res_stn_pco2$padj < 0.05 & !is.na(res_stn_pco2$padj) & res_trt$log2FoldChange > 0, ])

#sponge high vs no sponge high
downsshn <- row.names(res_shn_pco2[res_shn_pco2$padj < 0.05 & !is.na(res_shn_pco2$padj) & res_trt$log2FoldChange < 0, ])
upsshn <- row.names(res_shn_pco2[res_shn_pco2$padj < 0.05 & !is.na(res_shn_pco2$padj) & res_trt$log2FoldChange > 0, ])

## Compile DEG dataframe
DEG_bar <- data.frame("treat" = c(toString(unlist(str_split(res_con_sponge@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_con_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_trt@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_trt_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_stn_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_shn_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)])), 
                "up" = c(length(upCon_S), length(upTrt_N), length(upTrt_S), length(uptrtS), length(upslsh), length(upsshn)), 
                "down" = c((length(downCon_S) * -1), (length(downTrt_N) * -1), (length(downTrt_S) * -1), (length(downtrtS) * -1), (length(downslsh) * -1), (length(downsshn) * -1)))

DEG_bar <- gather(DEG_bar, reg, genes, up:down)

split_stringfunc <- function(x) {
  toString(unlist(str_split(x@elementMetadata@listData[["description"]][2], " "))[c(8,6)])
}

split_stringfunc(res_trt)

```

```{r DEG plot}

## Plot bar graph of DEG

ggplot(data = DEG_bar, aes(x = treat, y = genes, fill = reg)) +
  theme_classic() +
  geom_bar(stat="identity") +
  scale_fill_manual(values = c("cadetblue2", "coral")) +
  geom_hline(yintercept = 0, linetype = "dashed", size=0.5) + 
  ylab("Sig DEGs") +
  theme(legend.position = "none", axis.text.x = element_text(angle = 90)) +
  xlab ("")

ggsave("Figures/FigureXX_DEGsBar.pdf", width = 6, height = 4)
ggsave("Figures/FigureXX_DEGsBar.png", width = 6, height = 4)

```

Figure: Bar plot of significant DEGs. The y axis denotes how many genes there are, with positive values being up-regulated genes, and negative values denoting down-regulated genes. 

<br/>
<br/>


### Paired Venns of DEGs

```{r paired Venns}

## Comparing up NS_400 vs S_2800 and up S_2800 vs NS_2800
venn_loci_df <- list("NS_400 vs S_2800" = upTrt_S, "S_2800 vs NS_2800" = upsshn)

## Comparing up NS_400 vs S_2800 and up S_2800 vs NS_2800
venn_loci_up <- list("NS_400 vs S_2800" = upTrt_S, "S_2800 vs NS_2800" = uptrtS)

## Comparing down NS_400 vs S_2800 and up S_2800 vs NS_2800
venn_loci_down <- list("NS_400 vs S_2800" = downTrt_S, "S_2800 vs NS_2800" = downsshn)

## Comparing down NS_400 vs S_2800 and down S_2800 vs S_400
venn_loci2_down <- list("NS_400 vs S_2800" = downTrt_S, "S_2800 vs NS_2800" = downtrtS)

## Plot the seperate venn diagrams
ven1 <- ggvenn(venn_loci_df, 
       show_percentage=FALSE,
       fill_color = c("darkorange", "coral"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "#C8322F", set_name_size = 3,
       )

ven2 <- ggvenn(venn_loci_up, 
       show_percentage=FALSE,
       fill_color = c("darkorange", "coral"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "#C8322F", set_name_size = 3,
       )

ven3 <- ggvenn(venn_loci_down, 
       show_percentage=FALSE,
       fill_color = c("cyan4", "cornflowerblue"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 3,
       )

ven4 <- ggvenn(venn_loci2_down, 
       show_percentage=FALSE,
       fill_color = c("cyan4", "cornflowerblue"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 3,
       )


## Combine and save plot
ggarrange(ven1, ven2, ven3, ven4)
ggsave("Figures/FigureXX_PairedVens.pdf", width = 4, height = 4)
ggsave("Figures/FigureXX_PairedVens.png", width = 4, height = 4)

```

Figure 4: Venn diagrams depicting number of shared significantly up-regulated / down-regulated genes. Orange venn diagrams depict up-regulated genes, while blue depicts down-regulated genes. 

<br/>
<br/>

### Full Venns of DEGs

Need to add all treatments with DEGs to the below code (ANGELA)

```{r full venns}

## Venn of up DEGs
venn_up <- list("NS_400 vs S_2800" = upTrt_S, "S_2800 vs NS_2800" = uptrtS, "S_2800 vs NS_2800" = upsshn, "N_2800 vs S_400" = upslsh)

## Comparing down NS_400 vs S_2800 and up S_2800 vs NS_2800
venn_down <- list("NS_400 vs S_2800" = downTrt_S, "S_2800 vs NS_2800" = downsshn, "S_2800 vs NS_2800" = downtrtS)


## Plot the seperate venn diagrams
ven_up <- ggvenn(venn_up, 
       show_percentage=FALSE,
       fill_color = c("darkorange", "coral", "red", "cornsilk2"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "#C8322F", set_name_size = 2,
       )

ven_down <- ggvenn(venn_down, 
       show_percentage=FALSE,
       fill_color = c("cyan4", "cornflowerblue", "darkslategray3"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 3,
       )

## Combine and save plot
ggarrange(ven_up, ven_down)
ggsave("Figures/FigureXX_fullVens.pdf", width = 3, height = 2)
ggsave("Figures/FigureXX_fullVens.png", width = 3, height = 2)

```

Figure 5: left: four-way venn diagram showing relationships among up-regulated genes between different treatment comparisons. right: venn diagram showing relationships among down-regulated genes between treatment comparisons with significantly down-regulated genes.

<br/>
<br/>


## Gene expression plasticity {.tabset}

```{r}

mycolors <- c("aquamarine3", "red", "darkorange")

#### here is the code from the function without modifications:
## To run the function, enter the following objects:
# PCAplast(pca = XXX, # the PCA dataframe containing the PCA eigenvalues
#          data = XXX, # the condition/treatment data corresponding to samples
#          sample_ID = "XXX", # the name of column that provide unique ID per sample (if blank, will pull rownames for this)
#          num_pca =  "XXX", # the number of PCAs to include in analysis (default is 'all', but you can specify another number with a minimum of 2 PCAs)
#          control_col = "XXX", # what the 'treatment' column is called
#          control_lvl = "XXX", # control level of the treatment. If blank, a control mean per control level is assumed
#          group = "XXX") # the grouping column (i.e., colony). If blank, will assume control level grouping only!




## To run the function, enter the following objects:
ge_plast_all <-  PCAplast(pca = pcaData[6:31], # the PCA dataframe containing the PCA eigenvalues
                      data = pcaData[-6:-31], # the condition/treatment data corresponding to samples
                      num_pca =  "all", # the number of PCAs to include in analysis (default is 'all', but you can specify another number with a minimum of 2 PCAs)
                      control_col = "treat", # what the 'treatment' column is called
                      control_lvl = "N_400") # control level of the treatment. If blank, a control mean per level is assumed

#plasticity plot 1
pca_all_plot <- ggplot(data = ge_plast_all, aes(x = treat, y = dist, colour = treat, fill = treat)) + 
  geom_point(position = position_dodge(width = 0.5), aes(color = treat)) + 
  scale_colour_manual(values = mycolors) +
  scale_fill_manual(values = mycolors) +
  geom_boxplot(alpha = 0.2) +
  xlab("Treatment") +
  ggtitle("B)")


ge_plast_2 <-  PCAplast(pca = pcaData[6:31], # the PCA dataframe containing the PCA eigenvalues
                      data = pcaData[-6:-31], # the condition/treatment data corresponding to samples
                      num_pca =  "2", # the number of PCAs to include in analysis (default is 'all', but you can specify another number with a minimum of 2 PCAs)
                      control_col = "treat", # what the 'treatment' column is called
                      control_lvl = "N_400") # control level of the treatment. If blank, a control mean per level is assumed

#plasticity plot2
pca2_plot <- ggplot(data = ge_plast_2, aes(x = treat, y = dist, colour = treat, fill = treat)) + 
  geom_point(position = position_dodge(width = 0.5), aes(color = treat)) + 
  scale_colour_manual(values = mycolors) +
  scale_fill_manual(values = mycolors) +
  geom_boxplot(alpha = 0.2) +
  xlab("Treatment") +
  ggtitle("A)")
```

<br/>
<br/>

### ANOVA Tests on Plasticity Data

ANOVA test on plasticity data with 2 PCAs (looking at variable treat to see if there is any significant difference of dist)
``` {r}
# ANOVA test
res_aov <- aov(dist ~ treat,
  data = ge_plast_2
)
summary(res_aov)

TukeyHSD(res_aov, conf.level=.95)
```

ANOVA test on plasticity data with all PCAs (looking at variable treat to see if there is any significant difference of dist)
```{r}
# ANOVA test ge_plast_all
res_aov_all <- aov(dist ~ treat,
  data = ge_plast_all
)
summary(res_aov_all)

TukeyHSD(res_aov_all, conf.level=.95)
```

<br/>
<br/>

ANOVA test on plasticity data with all PCAs (looking at variable pCO2 * infect to see if there is any significant difference of dist)

```{r}
# ANOVA test ge_plast_all
res_aov_pco2_infect <- aov(dist ~ pCO2 * infect,
  data = ge_plast_all
)
summary(res_aov_pco2_infect)
res_aov_pco2_infect

TukeyHSD(res_aov_pco2_infect, conf.level=.95)
```

<br/>
<br/>

ANOVA test on plasticity data with all PCAs (looking at variable pCO2 * infect to see if there is any significant difference of dist)

```{r}
# ANOVA test ge_plast_2
res_aov_two_pco2_infect <- aov(dist ~ pCO2 * infect,
  data = ge_plast_2
)
summary(res_aov_two_pco2_infect)
res_aov_two_pco2_infect

TukeyHSD(res_aov_two_pco2_infect, conf.level=.95)
```

<br/>
<br/>

ANOVA test on plasticity data with all PCAs (looking at variable treat to see if there is any significant difference of dist)
```{r}
# ANOVA test ge_plast_all
res_aov_all <- aov(dist ~ treat,
  data = ge_plast_all
)
summary(res_aov_all)

res_aov_all

TukeyHSD(res_aov_all, conf.level=.95)
```
<br/>
<br/>

### Plasticity Plots

```{r}

# calculate mean and standard error for ge_plast_1
plasticity1_means_se <- ge_plast_all %>%  
  group_by(treat) %>% 
  summarize(mean_N=mean(dist), 
            sd_N=sd(dist), 
            N_N=n(), 
            se=sd_N/sqrt(N_N)
  ) 

# calculate mean and standard error for ge_plast_2
plasticity_means_se <- ge_plast_2 %>%  
  group_by(treat) %>% 
  summarize(mean_N=mean(dist), 
            sd_N=sd(dist), 
            N_N=n(), 
            se=sd_N/sqrt(N_N)
  ) 

#plot means and standard error
mean_se_plot <- ggplot(plasticity_means_se, aes(x=treat, y=mean_N, colour = treat)) + 
  geom_point(color = mycolors, size = 9, shape = "-") +
  geom_errorbar(aes(ymin=mean_N-se, ymax=mean_N+se), width=0.2, size=0.5, color = mycolors) +
  scale_colour_manual(values = mycolors) +
  ylab("Mean of Dist") +
  ggtitle("C)") +
  theme(legend.position = "none") +
  geom_point(data = ge_plast_2, aes(x = treat, y = dist, color = treat), alpha = 0.3)

mean_se_plot_all <- ggplot(plasticity1_means_se, aes(x=treat, y=mean_N, colour = treat)) + 
  geom_point(color = mycolors) +
  geom_errorbar(aes(ymin=mean_N-se, ymax=mean_N+se), width=0.2, size=0.5, color = mycolors) +
  scale_colour_manual(values = mycolors) +
  ylab("Mean of Dist") +
  ggtitle("D)") +
  theme(legend.position = "none") +
  geom_point(data = ge_plast_all, aes(x = treat, y = dist, color = treat), alpha = 0.3)

ggarrange(pca2_plot, pca_all_plot, mean_se_plot, mean_se_plot_all, common.legend = TRUE)


```

Figure 6: Assessment of plasticity (A-D) calculated as the average of the distances of each sample to the mean eigenvalue of the control (N_400). The control was omitted from this analysis. A) and C) pertains to analysis of all PCAs, while B) and D) contain analysis of 2 PCAs. A-B depicts box plots of plasticity and each individual sample as a point, while C-D shows the mean and standard error.

## Results
Infected oyster samples in the 2800 pCO2 treatment exhibited the highest plasticity (Figure __), but results from the ANOVA test with all PCAs suggest this was not statistically significant (p = 0.17, F = .967). Oysters not infected with sponge and in the 2800 treatment had the lowest plasticity (Figure _).

<br/>
<br/>


## GO for DESeq {.tabset}

```{r GO input, include = FALSE}

## create GO input dataframe
GO_DEGs <- data.frame(rn = row.names(res_trt), res_trt) %>% # make results a dataframe with rownames as column
  mutate(mutated_p = -log(pvalue)) %>% # take neg log of the p values
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p * -1, mutated_p)) %>% # change sign of data
  dplyr::select(rn, mutated_p_updown) %>% # select gene and modified p value columns only
  na.omit()


## need to rename the gene IDs with the names in the GO  file
seq2iso <- read.table("GO_MWU/GO_scripts/CVIR_seq2iso.tab")

GO_DEGs_rename <- left_join(GO_DEGs, seq2iso, by = c("rn" = "V1")) %>% 
  na.omit() %>% 
  dplyr::select(V2, mutated_p_updown)

colnames(GO_DEGs_rename) <- NULL # remove the column names


write.csv(GO_DEGs_rename, "GO_MWU/GO_files/DEG_GOinput.csv", row.names = FALSE, quote = FALSE) # save output

```

```{r GO_MWU for DEGs, eval = FALSE, include = FALSE}

### The following code was created by Mikhail V. Matz (UT Austin, February 2015; matz@utexas.edu) but was modified by Colleen B Bove (January 2022; colleenbove@gmail.com) to loop through all files at once


# GO_MWU uses continuous measure of significance (such as fold-change or -log(p-value) ) to identify GO categories that are significantly enriches with either up- or down-regulated genes. The advantage - no need to impose arbitrary significance cutoff.

# If the measure is binary (0 or 1) the script will perform a typical "GO enrichment" analysis based Fisher's exact test: it will show GO categories over-represented among the genes that have 1 as their measure. 

# On the plot, different fonts are used to indicate significance and color indicates enrichment with either up (red) or down (blue) regulated genes. No colors are shown for binary measure analysis.

# The tree on the plot is hierarchical clustering of GO categories based on shared genes. Categories with no branch length between them are subsets of each other.

# The fraction next to GO category name indicates the fracton of "good" genes in it; "good" genes being the ones exceeding the arbitrary absValue cutoff (option in gomwuPlot). For Fisher's based test, specify absValue=0.5. This value does not affect statistics and is used for plotting only.

#####################################################################################


## Edit these to match your data file names: 
goAnnotations = "CVIR_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase = "GO_MWU/GO_scripts/go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml (downloaded 06 July 2022)
iso_path = "GO_MWU/GO_scripts/" # path to GO MWU scripts
trait_path = "GO_MWU/GO_files/" # path to module files
GO_path = "GO_MWU/GO_files/Significant_GO_files/" # path to save module files with significant GO terms
figure_out_path = "GO_MWU/GO_figures/" # path where to save GO trees

# source the modified code
source("GO_MWU/GO_scripts/gomwuFunctions_CBBedits.R")


## to set custom colours
cols <- c("dodgerblue2","firebrick1","skyblue2","lightcoral")



#####################################################################################
############################## GO enrichment analysis ###############################
#####################################################################################

## Pull all filenames for the GO files
# two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either significant or not).
filenames <- list.files(trait_path, pattern="_GOinput.csv", full.names = FALSE)

filename <- filenames %>% 
  str_detect("CC_|MF_|BP_|MWU_|.tmp", negate = TRUE) %>%  # this is important to not include the csv files from other runs
  keep(filenames, .)

divisions <- c("CC", "MF", "BP")

for(d in divisions) {
  
  goDivision <- d # set the division
  
  for(f in filename) {
    
    input <- f # the input file name
    
    # Calculating stats
    gomwuStats(input, goDatabase, goAnnotations, goDivision, iso_path, trait_path,
               largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
               smallest=5,   # a GO category should contain at least this many genes to be considered
               clusterCutHeight=0.01, # threshold for merging similar (gene-sharing) terms. See README for details.
               #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
               #Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
               #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
    )
    
  }
}



#####################################################################################
### Identify modules with significant GO terms and save those terms to new folder ###
#####################################################################################

filenames <- list.files(trait_path, pattern="*_GOinput.csv", full.names = FALSE)

# selects the correct files for significant GO terms
filenames_sig <- filenames %>% 
  str_detect("\\MWU_", negate = FALSE) %>%
  keep(filenames, .)

for(f in filenames_sig) {
  mwu_file <- f
  mwu_out <- read.table(paste(trait_path, mwu_file, sep = ""), sep = " ", header = TRUE)
  
  str_name <- unlist(str_split(mwu_file, "_")) # split up the file name string
  goDivision <- str_name %>% str_detect("\\CC|\\MF|\\BP", negate = FALSE) %>% keep(str_name, .) # keep MWU files 
  sig_GO <- mwu_out[mwu_out$p.adj < 0.1, ] # pull the significant GO terms per module file
  GO_output <- paste(GO_path, str_name[2], "_", str_name[3], "_GOinput_sigGO.tsv", sep = "") # set the save path
  
  # saves files to path for significant GO terms
  if (nrow(sig_GO) > 0){
    sig_GO %>%  write_csv(file = GO_output)
  }
  
}



#####################################################################################
############## Plot significant GO term trees from identified modules ###############
#####################################################################################

sig_files_plot <- list.files(GO_path, pattern = "*.tsv", full.names = FALSE)

divisions <- c("CC", "MF", "BP")

for(d in divisions) {
  #d = "CC"
  goDivision <- d # set the division
  
  for (f in sig_files_plot){
    input <- f
    str_name <- unlist(str_split(input, "_")) # split up the file name string
    GO_fig_path <- paste(figure_out_path, str_name[1], "_", str_name[2], "_tree.pdf", sep = "")
    
    num_terms <- nrow(read.table(paste0(GO_path, input), sep = ",")) # count # of terms for tree height
    
    if(num_terms >= 3) {
      pdf(GO_fig_path, height = ifelse(num_terms > 3, (num_terms/7), 0.65), width = 5, useDingbats = FALSE)
      gomwuPlot(input, goAnnotations, goDivision, iso_path, trait_path, GO_path,
                # absValue=0.001, # -log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
                absValue=1, # un-remark this if you are using log2-fold changes
                level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
                level2=0.01, # FDR cutoff to print in regular (not italic) font.
                level3=0.001, # FDR cutoff to print in large bold font.
                txtsize=1,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
                treeHeight=0.5, # height of the hierarchical clustering tree
                colors = cols
      )
      dev.off()
    } else {
      print(paste(gsub("_sigGO.tsv", "", input), "contains fewer than 3 GO terms, no tree produced"))
    }
      }
}

```

```{r GO terms PDF to PNG and plot, eval=FALSE, include=FALSE}

library(pdftools)


### Function to take PDF and convert to PNG

PDF2plot <- function(path) {
  
  # Make a list of all filenames in selected directory
  filenames <- list.files(path = path, pattern = "*.pdf") 
  
  ## Forloop to convert PDF images to PNGs, plot them, and then save them to list
  for(i in 1:length(filenames)){
    file_ext <- filenames[i] # pull file name (with extension)
    file_name <- tools::file_path_sans_ext(file_ext) # file name withOUT extension
    bitmap <- pdftools::pdf_render_page(paste0(path, file_ext), page = 1, dpi = 300) # render PDF image as bitmap
    png::writePNG(bitmap, paste0(path, file_name, ".png")) # convert bitmap to .png and save in same directory
  }
  
}

################################################################################

## Run PDF2plot function  
PDF2plot(path = "GO_MWU/GO_figures/")

```

Example of a heatmap for a GO term
```{r eval=FALSE, include=FALSE}

gene <- read.delim("GO_MWU/GO_scripts/CVIR_iso2gene.tab", sep = "\t", header = FALSE) 


## need to replace loci ID with sequence ID
gene_rename <- left_join(gene, seq2iso, by = c("V1" = "V1")) %>% 
  na.omit() %>% 
  dplyr::select(V2.y, V2.x) %>% 
  dplyr::rename("gene" = "V2.y", "gene_name" = "V2.x")


iso2go <- read_tsv("GO_MWU/GO_scripts/CVIR_iso2go.tab", col_names = FALSE) %>% 
  dplyr::rename("gene" = "X1", "GO_id" = "X2")


GO_0005975 <- iso2go %>%
  filter(str_detect(GO_id, "GO:0005975")) %>%
  left_join(gene_rename) %>%
  left_join(cold_rlog) %>%
  #mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  #column_to_rownames(var = "gene_symbol") %>%
  #dplyr::select(-GO_id, -Gene, -Iso) %>%
  drop_na()
  #dplyr::select(sort(current_vars()))

GO_0016459_cold_means = apply(GO_0005975,1,mean) # means of rows
explc = GO_0005975-GO_0016459_cold_means # subtracting them

# plot heatmap
heatmap.2(as.matrix(GO_0005975), col = cold_colour, Rowv = TRUE, Colv = FALSE, scale = "row",
          dendrogram = "both",
          trace = "none",
          main = "GO:0016459 myosin complex",
          margin = c(5,15))

```

<br/>
<br/>


## Colleen adding in WGCNA

*It will go here*

<br/>
<br/>

  
## Session Information

Session information from the last full knit of Rmarkdown on `r format(Sys.time(), '%d %B %Y')`.

```{r session info}

sessionInfo()

```